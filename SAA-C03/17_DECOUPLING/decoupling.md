# sqs

핵심 키워드는 대기열 입니다. 

표준 대기열용 amazon sqs는 가장 오래된 서비스로 완전 관리형 서비스로 애플리케이션을 *분리하는 데 사용됩니다*

무제한 처리량을 얻을 수 있습니다. 처리량에 제한 이 없고 대기열에 있는 메시지 수에도 제한이 없습니다. 각 메시지는 수명이 짧습니다. 

sqs는 대기열 서비스이므로 높은 처리량, 높은 볼륨 등이 있어서 중복 메시지가 있을 수 있습니다. 

생산자는 간단하며 소비자는 일부 코드로 작성해야 하는 애플리케이션이고 aws 가상 서버에서 실행될 수 있습니다. lambda 함수 및 온프레미스 서버에서 실행 가능합니다. 

소비자들은 동시에 가질 수 있습니다. asg와 더불어 sqs를 사용하는것은 완벽한 사례입니다.

sqs 대기열에서 쓸 수있는 cloudwatch 지표는 대기열의 길이 입니다. 

*또한 프론트엔드의 경우 최적의 유형의 EC2 인스턴스 또는 아키텍처를
프론트엔드에 사용할 수 있습니다 백엔드의 경우
비디오 처리를 수행할 때 그래픽 처리 장치인 GPU가 있는 일부
EC2 인스턴스를 사용할 수 있습니다
이러한 유형의 인스턴스가
워크로드를 수행하는 데에 최적이기 때문입니다*

액세스 제어를 위해 IAM 정책은
SQS API에 대한 액세스를 규제할 수 있고
S3 버킷 정책과 유사한
SQS 액세스 정책도 있습니다

# sqs 메시지 가시성 시간 초과 

기본값으로는 메시지 가시성 시간 초과는 30 초입니다. *시간 초과 기간 내에 또 다른 요청이 들어와도 메시지가 반환 되지 않습니다. 즉 가시성 시간 초과 기간 내에서는 그 메시지는 다른 소비자들에게 보이지 않습니다.* 

*가시성 시간 초과가 경과되고 메시지가 삭제되지 않았다면 메시지는 대기열에 다시 넣습니다. 그럼 다른 소비자는 이전의 메시지를 받게 되고 중복 처리할 수 있는겁니다*


# sqs long polling

*sqs 대기열에 대한 api 호출 수를 최적화하고 지연시간을 줄이는 방법은 롱폴링입니다. 
롱폴링은 대기열에 아무것도 없다면 메시지 도착을 기다립니다.* 

# sqs fifo queue

이 SQS 대기열의 처리량에는 제한이 있습니다
묶음이 아닐 경우에는 초당 300개의 메시지를 처리하고
메시지를 묶음으로 보낸다면
그 처리량은 초당 3,000개가 됩니다
FIFO 대기열을 사용해서 순서를 확실히 할 수 있죠

# sqs with asg

asg 그룹을 자동으로 대기열 크기에 따라 확장시키기 위함으로 cloudwatch 지표인 대기열 길이를 보고 결정 가능합니다. 

*시나리오 중에 해당 고객 트랜잭션은 유실되고 이는 특정 트랜잭션에 오류가 발생한다면 쓰기 대상 db에서 sqs를 버퍼로 사용 가능합니다. db와 frontend 애플리케이션이 있다면 db에 바로 쓰는 대신 애플리케이션이 요청, 즉 트랜잭션을 일명 무한히 확장 가능 sqs 대기열에 먼저 쓰는 방법이 있습니다. 이렇게 하면 처리량 문제가 발생하지 않습니다. 여기서 asg 그룹으로 메시지를 대기열에서 제외 가능합니다.*

*지금 이 오토 스케일링 그룹의 유일한 목적은 메시지를 수신해서
데이터베이스로 삽입하는 작업이죠
메시지가 데이터베이스에 삽입되고 나면
기존 SQS 대기열에서 해당 메시지를 삭제합니다
이렇게 SQS를 버퍼로 사용하여
모든 트랜잭션이 데이터베이스에 쓰이도록 확인할 수 있습니다*

*이 패턴은 클라이언트에게 따로 데이터베이스에
쓰였다는 확인을 전송할 필요가 없을 때만 사용 가능합니다
하지만 SQS 대기열에 쓰기 작업이 일어났다는 것만으로도
결국 데이터베이스에 요청이 쓰일 테니 일종의 확인을 한 셈이죠
이는 데이터베이스 쓰기 간 분리와 애플리케이션 티어 간 분리에 활용되는데
애플리케이션이 요청을 전달받고
처리한 후 응답을 재전송하는 대신
이 과정을 분리하여 모든 요청을
프론트엔드 웹 애플리케이션에서 받고 해당 요청을 SQS 대기열로 전송하여
백엔드 처리 작업이 메시지를 전달받은 다음
준비되면 메시지를 처리하고 필요에 따라 스케일링하는 거죠*

*분리나 급격히 증가한 로드 혹은 시간초과 등의 문제에서
신속한 스케일링이 필요한 경우에는
SQS 대기열을 기억하시기 바랍니다*
